<?hh
namespace Elastica;

use Elastica\Exception\InvalidException;
use Elastica\Exception\NotFoundException;
use Elastica\Exception\RuntimeException;
use Elastica\Type\Mapping;
use Indexish;

type Serializer = (function (mixed): string);

/**
 * Elastica type object.
 *
 * elasticsearch has for every types as a substructure. This object
 * represents a type inside a context
 * The hierarchy is as following: client -> index -> type -> document
 *
 * @author   Nicolas Ruflin <spam@ruflin.com>
 */
class Type implements SearchableInterface
{
    /**
     * Index.
     *
     * @var \Elastica\Index Index object
     */
    protected Index $_index;

    /**
     * Type name.
     *
     * @var string Type name
     */
    protected string $_name = '';

    /**
     * @var array|string A callable that serializes an object passed to it
     */
    protected Serializer $_serializer;

    /**
     * Creates a new type object inside the given index.
     *
     * @param \Elastica\Index $index Index Object
     * @param string          $name  Type name
     */
    public function __construct(Index $index, string $name)
    {
        $this->_index = $index;
        $this->_name = $name;
        $this->_serializer = inst_meth($this, 'noSerializer');
    }

    public function noSerializer(mixed $_) : string {
        throw new RuntimeException('No serializer defined');
    }

    /**
     * Adds the given document to the search index.
     *
     * @param \Elastica\Document $doc Document with data
     *
     * @return Awaitable<\Elastica\Response>
     */
    public async function addDocument(Document $doc) : Awaitable<Response>
    {
        $path = urlencode($doc->getId());

        $type = Request::PUT;

        // If id is empty, POST has to be used to automatically create id
        if (empty($path)) {
            $type = Request::POST;
        }

        $options = $doc->getOptions(
            array(
                'version',
                'version_type',
                'routing',
                'percolate',
                'parent',
                'ttl',
                'timestamp',
                'op_type',
                'consistency',
                'replication',
                'refresh',
                'timeout',
            )
        );

        $response = await $this->request($path, $type, $doc->getData(), $options);

        $data = $response->getData();
        if (!$data instanceof Indexish) {
            throw new \RuntimeException('expected array');
        }
        // set autogenerated id to document
        if (($doc->isAutoPopulate()
                || $this->getIndex()->getClient()->getConfigValue(array('document', 'autoPopulate'), false))
            && $response->isOk()
        ) {
            if (!$doc->hasId()) {
                if (isset($data['_id'])) {
                    $doc->setId($data['_id']);
                }
            }
            if (isset($data['_version'])) {
                $doc->setVersion($data['_version']);
            }
        }

        return $response;
    }

    /**
     * @param $object
     * @param Document $doc
     *
     * @throws Exception\RuntimeException
     *
     * @return Awaitable<Response>
     */
    public function addObject(mixed $object, ?Document $doc = null) : Awaitable<Response>
    {
        $data = call_user_func($this->_serializer, $object);

        if (!$doc) {
            $doc = new Document();
        }
        $doc->setData($data);

        return $this->addDocument($doc);
    }

    /**
     * Update document, using update script. Requires elasticsearch >= 0.19.0.
     *
     * @link http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html
     *
     * @param \Elastica\Document|\Elastica\Script $data    Document with update data
     * @param array                               $options array of query params to use for query. For possible options check es api
     *
     * @throws \Elastica\Exception\InvalidException
     *
     * @return Awaitable<\Elastica\Response>
     */
    public function updateDocument($data, array $options = array()) : Awaitable<Response>
    {
        if (!($data instanceof Document) && !($data instanceof Script)) {
            throw new \InvalidArgumentException('Data should be a Document or Script');
        }

        if (!$data->hasId()) {
            throw new InvalidException('Document or Script id is not set');
        }

        $id = urlencode($data->getId());

        return $this->getIndex()->getClient()->updateDocument(
            $id,
            $data,
            $this->getIndex()->getName(),
            $this->getName(),
            $options
        );
    }

    /**
     * Uses _bulk to send documents to the server.
     *
     * @param array|\Elastica\Document[] $docs Array of Elastica\Document
     *
     * @return Awaitable<\Elastica\Bulk\ResponseSet>
     *
     * @link http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html
     */
    public function updateDocuments(array $docs) : Awaitable<Bulk\ResponseSet>
    {
        foreach ($docs as $doc) {
            $doc->setType($this->getName());
        }

        return $this->getIndex()->updateDocuments($docs);
    }

    /**
     * Uses _bulk to send documents to the server.
     *
     * @param array|\Elastica\Document[] $docs Array of Elastica\Document
     *
     * @return Awaitable<\Elastica\Bulk\ResponseSet>
     *
     * @link http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html
     */
    public function addDocuments(array $docs) : Awaitable<Bulk\ResponseSet>
    {
        foreach ($docs as $doc) {
            $doc->setType($this->getName());
        }

        return $this->getIndex()->addDocuments($docs);
    }

    /**
     * Uses _bulk to send documents to the server.
     *
     * @param objects[] $objects
     *
     * @return Awaitable<\Elastica\Bulk\ResponseSet>
     *
     * @link http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html
     */
    public function addObjects(array $objects) : Awaitable<Bulk\ResponseSet>
    {
        $docs = array();
        foreach ($objects as $object) {
            $data = call_user_func($this->_serializer, $object);
            $doc = new Document();
            $doc->setData($data);
            $doc->setType($this->getName());
            $docs[] = $doc;
        }

        return $this->getIndex()->addDocuments($docs);
    }

    /**
     * Get the document from search index.
     *
     * @param string $id      Document id
     * @param array  $options Options for the get request.
     *
     * @throws \Elastica\Exception\NotFoundException
     * @throws \Elastica\Exception\ResponseException
     *
     * @return Awaitable<\Elastica\Document>
     */
    public async function getDocument(string $id, array $options = array()) : Awaitable<Document>
    {
        $path = urlencode($id);

        $response = await $this->request($path, Request::GET, array(), $options);
        $result = $response->getData();

        if (!$result instanceof Indexish) {
            throw new \RuntimeException('expected array');
        }
        if (!isset($result['found']) || $result['found'] === false) {
            throw new NotFoundException('doc id '.$id.' not found');
        }

        if (isset($result['fields'])) {
            $data = $result['fields'];
        } elseif (isset($result['_source'])) {
            $data = $result['_source'];
        } else {
            $data = array();
        }

        $document = new Document($id, $data, $this->getName(), $this->getIndex());
        $document->setVersion($result['_version']);

        return $document;
    }

    /**
     * @param string       $id
     * @param array|string $data
     *
     * @return Document
     */
    public function createDocument(?string $id = '', mixed $data = array()) : Document
    {
        $document = new Document($id, $data);
        $document->setType($this);

        return $document;
    }

    /**
     * Returns the type name.
     *
     * @return string Type name
     */
    public function getName() : string
    {
        return $this->_name;
    }

    /**
     * Sets value type mapping for this type.
     *
     * @param \Elastica\Type\Mapping|array $mapping Elastica\Type\MappingType object or property array with all mappings
     *
     * @return Awaitable<\Elastica\Response>
     */
    public function setMapping(mixed $mapping) : Awaitable<Response>
    {
        $mapping = Mapping::create($mapping);
        $mapping->setType($this);

        return $mapping->send();
    }

    /**
     * Returns current mapping for the given type.
     *
     * @return Awaitable<array> Current mapping
     */
    public async function getMapping() : Awaitable<array>
    {
        $path = '_mapping';

        $response = await $this->request($path, Request::GET);
        $data = $response->getData();

        $mapping = array_shift($data);
        if (isset($mapping['mappings'])) {
            return $mapping['mappings'];
        }

        return array();
    }

    /**
     * Create search object.
     *
     * @param string|array|\Elastica\Query $query   Array with all query data inside or a Elastica\Query object
     * @param int|array                    $options OPTIONAL Limit or associative array of options (option=>value)
     *
     * @return \Elastica\Search
     */
    public function createSearch(mixed $query = '', mixed $options = null) : Search
    {
        $search = new Search($this->getIndex()->getClient());
        $search->addIndex($this->getIndex());
        $search->addType($this);
        $search->setOptionsAndQuery($options, $query);

        return $search;
    }

    /**
     * Do a search on this type.
     *
     * @param string|array|\Elastica\Query $query   Array with all query data inside or a Elastica\Query object
     * @param int|array                    $options OPTIONAL Limit or associative array of options (option=>value)
     *
     * @return Awaitable<\Elastica\ResultSet> ResultSet with all results inside
     *
     * @see \Elastica\SearchableInterface::search
     */
    public function search(mixed $query = '', $options = null) : Awaitable<ResultSet>
    {
        $search = $this->createSearch($query, $options);

        return $search->search();
    }

    /**
     * Count docs by query.
     *
     * @param string|array|\Elastica\Query $query Array with all query data inside or a Elastica\Query object
     *
     * @return Awaitable<int> number of documents matching the query
     *
     * @see \Elastica\SearchableInterface::count
     */
    public async function count(mixed $query = '') : Awaitable<int>
    {
        $search = $this->createSearch($query);
        $res = await $search->count();
        return (int) $res;
    }

    /**
     * Returns index client.
     *
     * @return \Elastica\Index Index object
     */
    public function getIndex() : Index
    {
        return $this->_index;
    }

    /**
     * @param \Elastica\Document $document
     *
     * @return Awaitable<\Elastica\Response>
     */
    public function deleteDocument(Document $document) : Awaitable<Response>
    {
        $options = $document->getOptions(
            array(
                'version',
                'version_type',
                'routing',
                'parent',
                'replication',
                'consistency',
                'refresh',
                'timeout',
            )
        );

        return $this->deleteById($document->getId(), $options);
    }

    /**
     * Uses _bulk to delete documents from the server.
     *
     * @param array|\Elastica\Document[] $docs Array of Elastica\Document
     *
     * @return Awaitable<\Elastica\Bulk\ResponseSet>
     *
     * @link http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html
     */
    public function deleteDocuments(array $docs) : Awaitable<Bulk\ResponseSet>
    {
        foreach ($docs as $doc) {
            $doc->setType($this->getName());
        }

        return $this->getIndex()->deleteDocuments($docs);
    }

    /**
     * Deletes an entry by its unique identifier.
     *
     * @link http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html
     *
     * @param int|string $id      Document id
     * @param array      $options
     *
     * @throws \InvalidArgumentException
     * @throws \Elastica\Exception\NotFoundException
     *
     * @return Awaitable<\Elastica\Response> Response object
     */
    public async function deleteById($id, Indexish<string, mixed> $options = array()) : Awaitable<Response>
    {
        if (empty($id) || !trim($id)) {
            throw new \InvalidArgumentException();
        }

        $id = urlencode($id);

        $response = await $this->request($id, Request::DELETE, array(), $options);

        $responseData = $response->getData();

        if (!$responseData instanceof Indexish) {
            throw new \RuntimeException('expected array');
        }
        if (isset($responseData['found']) && false == $responseData['found']) {
            throw new NotFoundException('Doc id '.$id.' not found and can not be deleted');
        }

        return $response;
    }

    /**
     * Deletes the given list of ids from this type.
     *
     * @param array        $ids
     * @param string|false $routing Optional routing key for all ids
     *
     * @return Awaitable<\Elastica\Response> Response  object
     */
    public function deleteIds(array $ids, mixed $routing = false) : Awaitable<Response>
    {
        return $this->getIndex()->getClient()->deleteIds($ids, $this->getIndex(), $this, $routing);
    }

    /**
     * Deletes entries in the db based on a query.
     *
     * @param \Elastica\Query|string $query   Query object
     * @param array                  $options Optional params
     *
     * @return Awaitable<\Elastica\Response>
     *
     * @link http://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html
     */
    public function deleteByQuery(mixed $query, array $options = array()) : Awaitable<Response>
    {
        if (is_string($query)) {
            // query_string queries are not supported for delete by query operations
            $options['q'] = $query;

            return $this->request('_query', Request::DELETE, array(), $options);
        }
        $query = Query::create($query);

        return $this->request('_query', Request::DELETE, array('query' => $query->getQuery()->toArray()), $options);
    }

    /**
     * Deletes the index type.
     *
     * @return Awaitable<\Elastica\Response>
     */
    public function delete() : Awaitable<Response>
    {
        $response = $this->request('', Request::DELETE);

        return $response;
    }

    /**
     * More like this query based on the given object.
     *
     * The id in the given object has to be set
     *
     * @param \Elastica\Document           $doc    Document to query for similar objects
     * @param array                        $params OPTIONAL Additional arguments for the query
     * @param string|array|\Elastica\Query $query  OPTIONAL Query to filter the moreLikeThis results
     *
     * @return Awaitable<\Elastica\ResultSet> ResultSet with all results inside
     *
     * @link http://www.elastic.co/guide/en/elasticsearch/reference/current/search-more-like-this.html
     */
    public async function moreLikeThis(Document $doc, array $params = array(), mixed $query = array()) : Awaitable<ResultSet>
    {
        $path = $doc->getId().'/_mlt';

        $query = Query::create($query);

        $response = await $this->request($path, Request::GET, $query->toArray(), $params);

        return ResultSet::create($response, $query);
    }

    /**
     * Makes calls to the elasticsearch server based on this type.
     *
     * @param string $path   Path to call
     * @param string $method Rest method to use (GET, POST, DELETE, PUT)
     * @param array|string  $data   OPTIONAL Arguments as array
     * @param array  $query  OPTIONAL Query params
     *
     * @return Awaitable<\Elastica\Response> Response object
     */
    public function request(string $path, string $method, mixed $data = array(), Indexish<string, mixed> $query = array()) : Awaitable<Response>
    {
        $path = $this->getName().'/'.$path;

        return $this->getIndex()->request($path, $method, $data, $query);
    }

    /**
     * Sets the serializer callable used in addObject.
     *
     * @see \Elastica\Type::addObject
     *
     * @param array|string $serializer @see \Elastica\Type::_serializer
     *
     * @return $this
     */
    public function setSerializer(Serializer $serializer) : this
    {
        $this->_serializer = $serializer;

        return $this;
    }

    /**
     * Checks if the given type exists in Index.
     *
     * @return Awaitable<bool> True if type exists
     */
    public async function exists() : Awaitable<bool>
    {
        $response = await $this->getIndex()->request($this->getName(), Request::HEAD);
        $info = $response->getTransferInfo();

        return (bool) ($info['http_code'] == 200);
    }
}
